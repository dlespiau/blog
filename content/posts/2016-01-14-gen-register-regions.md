+++
title = "GEN Register Regions"
date = 2016-01-14T11:29:00Z
updated = 2016-01-14T11:29:49Z
draft = true
blogimport = true 
[author]
	name = "Damien Lespiau"
	uri = "https://plus.google.com/114288295280403017038"
+++

<div dir="ltr" style="text-align: left;" trbidi="on">This post focuses on an (hopefully interesting!) detail of the <a href="https://software.intel.com/en-us/articles/intel-graphics-developers-guides">Intel GEN GPU architecture</a>, describing the direct addressing mode of GEN instructions running on the Execution Units (EUs). Those units are running the shaders of the various GPU APIs.<br /><br />It's unusual almost every programmer to encounter assembly instructions run by the GPU as graphics APIs have their own high level language (GLSL, HLSL, ...). With Mesa however, it's easy to get the driver to dump the actual GEN instructions GLSL is compiled down to.<br /><br />The following will dump interesting information about the vertex shader (vs) and the fragment shader (fs), including an estimation of how many EU cycles they need to run, handy to look at to have an idea of how expensive a particular shader is.<br /><br />$ INTEL_DEBUG=vs,fs glxgears<br /><br />mov(8) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;g124&lt;1&gt;F &nbsp; &nbsp; &nbsp; &nbsp;g2.3&lt;0,1,0&gt;F &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ align1 1Q compacted };<br />mov(8) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;g125&lt;1&gt;F &nbsp; &nbsp; &nbsp; &nbsp;g2.7&lt;0,1,0&gt;F &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ align1 1Q };<br />mov(8) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;g126&lt;1&gt;F &nbsp; &nbsp; &nbsp; &nbsp;g3.3&lt;0,1,0&gt;F &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ align1 1Q compacted };<br />mov(8) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;g127&lt;1&gt;F &nbsp; &nbsp; &nbsp; &nbsp;g3.7&lt;0,1,0&gt;F &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;{ align1 1Q };<br />sendc(8) &nbsp; &nbsp; &nbsp; &nbsp;null&lt;1&gt;UW &nbsp; &nbsp; &nbsp; g124&lt;8,8,1&gt;F<br />&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; render RT write SIMD8 LastRT Surface = 0 mlen 4 rlen 0 { align1 1Q EOT };<br /><div><br /></div><br />The fragment shader for glxgears is not very interesting as it's just writing a constant colour into the framebuffer. The vertex shader though has funny looking instructions:<br /><br />dp4(8) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;g115&lt;1&gt;.yF &nbsp; &nbsp; &nbsp;g6&lt;4,4,1&gt;F &nbsp; &nbsp; &nbsp;g1.4&lt;0,4,1&gt;F &nbsp; &nbsp;{ align16 NoDDChk 1Q }<br /><br />To understand what this does, one needs a small introduction to the EU architecture. Like every modern GPU, the main processing power comes from an array of small processors executing the shaders. Intel GPUs are no exception: a <a href="https://01.org/sites/default/files/documentation/intel-gfx-prm-osrc-skl-vol04-configurations.pdf">Skylake (SKL) GT2 GPU</a>&nbsp;has 24 EUs, each running 7 threads with possible co-issuing between different threads. Each thread has a pool of 128 registers of 256 bits (8 simple precision floats) to be used as scratch space for computation. Those registers are named g0 to g127 or r0 to r127 depending on who you talk to (actually the 'g' comes from <i>general </i>register, on older platforms registers weren't all equal). Further parallelism is achieved by having each thread handling several vertices or pixels in one go.<br /><br />The EUs only have arithmetic operations. Interaction with the rest of the system, eg. sampling from textures or writing into framebuffers are handled by shared units, shared among the EUs that is. To keep the SKL GT2 example above, there are only 3 samplers to fetch texels from, 1 sampler by group of 7 EUs. A shader communicates with the shared functions with the send instruction. The glxgears fragment shader above shows one of those, writing the color into the framebuffer (RT is for render target).<br /><br />So, back to the topic understanding that dp4 instruction and GEN regions. At a macro level that instruction reads:<br /><br />dp4 dst src0 src1<br /><br />or in english, do a dot product between the 4 components of vectors described by src0 and src1 and place the result into dst.<br /><br />The 128 256-bits per-thread registers are actually regarded as a big array of 32x128 bytes. The source and destination operands describe a rectangular region in that array of registers. Now let's try to decode, say, src1 ie g1.4&lt;0,4,1&gt;.<br /><br /><br /><br /><br /><br /></div>
