+++
title = "git commit --fixup and git rebase -i --autosquash"
date = 2014-01-20T11:18:00Z
updated = 2016-02-07T12:53:43Z
tags = ["Kernel"]
blogimport = true 
[author]
	name = "Damien Lespiau"
	uri = "https://plus.google.com/114288295280403017038"
+++

It's not unusual that I need to fix previous commits up when working  on a branch or in the review phase. Until now I used a regular commit with some special marker to remember which commit to squash it with and then git rebase -i to reorder the patches and squash the fixup commits with their corresponding "parent" commits.<br /><br />Turns out, git can handle quite a few of those manual manipulations for you. <code>git commit --fixup &lt;commit&gt;</code> allows you to commit work, marking it as a fixup of a previous commit. <code>git rebase -i --autosquash</code> will then present the usual <code>git rebase -i</code> screen but with the fixup commits moved just after their parents and ready to be squashed without any extra manipulation.<br /><br />For instance, I had a couple of changes to a commit buried 100 patches away from <code>HEAD</code> (yes, a big topic branch!):<br /><pre class="brush: diff; gutter: false">$ git diff<br />diff --git a/drivers/gpu/drm/i915/intel_display.c b/drivers/gpu/drm/i915/intel_display.c<br />index 29f3813..08ea851 100644<br />--- a/drivers/gpu/drm/i915/intel_display.c<br />+++ b/drivers/gpu/drm/i915/intel_display.c<br />@@ -2695,6 +2695,11 @@ static void skylake_update_primary_plane(struct drm_crtc *crtc,<br /><br />        intel_fb = to_intel_framebuffer(fb);<br />        obj = intel_fb-&gt;obj;<br />+<br />+       /*<br />+        * The stride is expressed either as a multiple of 64 bytes chunks for<br />+        * linear buffers or in number of tiles for tiled buffers.<br />+        */<br />        switch (obj-&gt;tiling_mode) {<br />        case I915_TILING_NONE:<br />               stride = fb-&gt;pitches[0] &gt;&gt; 6;<br />@@ -2707,7 +2712,6 @@ static void skylake_update_primary_plane(struct drm_crtc *crtc,<br />BUG();<br />}<br /><br />-       plane_ctl &amp;= ~PLANE_CTL_TRICKLE_FEED_DISABLE;<br />        plane_ctl |= PLANE_CTL_PLANE_GAMMA_DISABLE;<br /><br />        I915_WRITE(PLANE_CTL(pipe, 0), plane_ctl);</pre>And I wanted to squash those changes with commit <code>2021785</code><br /><pre class="brush: bash; gutter: false">$ git commit -a --fixup 2021785<br /></pre>git will then go ahead and create a new commit with the subject taken from the referenced commit and prefixed with <code>fixup!</code><br /><pre class="brush: bash; gutter: false">commit d2d278ffbe87d232369b028d0c9ee9e6ecd0ba20<br />Author: Damien Lespiau &lt;damien.lespiau@intel.com&gt;<br />Date:   Sat Sep 20 11:09:15 2014 +0100<br /><br />fixup! drm/i915/skl: Implement thew new update_plane() for primary planes</pre>Then when using the interactive rebase with autosquash:<br /><pre class="brush: bash; gutter: false">$ git rebase -i --autosquash drm-intel/drm-intel-nightly<br /></pre>The fixup will be next after the reference commit<br /><pre class="brush: bash; gutter: false">pick 2021785 drm/i915/skl: Implement thew new update_plane() for primary planes<br />fixup d2d278ff fixup! drm/i915/skl: Implement thew new update_plane() for primary planes</pre>validating the proposed change (by in my case leaving vim) will squash the fixup commits. Definitely what I'll be using from now on!<br /><br />Oh, and there's a config option to have git rebase automatically autosquash if there are some fixup commits:<br /><pre class="brush: bash; gutter: false">$ git config --global rebase.autosquash true</pre>
