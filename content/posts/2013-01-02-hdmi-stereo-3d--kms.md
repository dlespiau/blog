+++
title = "HDMI stereo 3D & KMS"
date = 2013-01-02T19:38:00Z
updated = 2016-02-06T18:28:46Z
tags = ["Kernel"]
blogimport = true 
[author]
	name = "Damien Lespiau"
	uri = "https://plus.google.com/114288295280403017038"
+++

<div dir="ltr" style="text-align: left;" trbidi="on">If everything goes according to plan, KMS in linux 3.13 should have stereo 3D support. Should one be interested in scanning out a stereo frame buffer to a 3D capable HDMI sink, here's a rough description of how those modes are exposed to user space and how to use them.<br /><br />A reader not well acquainted with the DRM sub-system and its mode setting API (Aka Kernel Mode Setting, KMS) could start by watching the first part of Laurent Pinchart's<em> <a href="http://www.youtube.com/watch?v=Ja8fM7rTae4" target="_blank">Anatomy of an Embedded KMS Driver</a></em> or read David Herrmann's heavily documented <a href="https://github.com/dvdhrm/docs/blob/master/drm-howto/modeset.c" target="_blank" title="Mode setting example">mode setting example</a> code.<br /><br />Stereo modes work by sending a left eye and right eye picture per frame to the monitor. It's then up to the monitor to use those 2 pictures to display a 3D frame and the technology there varies.<br /><br />There are different ways to organise the 2 pictures inside a bigger frame buffer. For HDMI, those layouts are described in the HDMI 1.4 specification. Provided you give them your contact details, it's possible to download the stereo 3D part of the HDMI 1.4 spec from <a href="http://www.hdmi.org/manufacturer/specification.aspx" target="_blank" title="HDMI stereo 3D extraction">hdmi.org</a>.<br /><br />As one inevitably knows, modes supported by a monitor can be retrieved out of the KMS connector object in the form of <code>drmModeModeInfo</code> structures (when using <a href="http://cgit.freedesktop.org/mesa/drm" target="_blank" title="libdrm git repository">libdrm</a>, it's also possible to write your own wrappers around the KMS ioctls, should you want to):<br /><pre class="brush: c; gutter: true; first-line: 1; highlight: []; html-script: false ">typedef struct _drmModeModeInfo {<br />        uint32_t clock;<br />        uint16_t hdisplay, hsync_start, hsync_end, htotal, hskew;<br />        uint16_t vdisplay, vsync_start, vsync_end, vtotal, vscan;<br /><br />        uint32_t vrefresh;<br /><br />        uint32_t flags;<br />        uint32_t type;<br />        char name[...];<br />} drmModeModeInfo, *drmModeModeInfoPtr;</pre>To keep existing software blissfully unaware of those modes, a DRM client interested in having stereo modes listed starts by telling the kernel to expose them:<br /><pre class="brush: c; gutter: true; first-line: 1; highlight: []; html-script: false ">drmSetClientCap(drm_fd, DRM_CLIENT_CAP_STEREO_3D, 1);</pre>Stereo modes use the <code>flags</code> field to advertise which layout the mode requires:<br /><pre class="brush: c; gutter: true; first-line: 1; highlight: []; html-script: false ">uint32_t layout = mode-&gt;flags &amp; DRM_MODE_FLAG_3D_MASK;</pre>This will give you a non zero value when the mode is a stereo mode, value among:<br /><pre class="brush: c; gutter: true; first-line: 1; highlight: []; html-script: false ">DRM_MODE_FLAG_3D_FRAME_PACKING<br />DRM_MODE_FLAG_3D_FIELD_ALTERNATIVE<br />DRM_MODE_FLAG_3D_LINE_ALTERNATIVE<br />DRM_MODE_FLAG_3D_SIDE_BY_SIDE_FULL<br />DRM_MODE_FLAG_3D_L_DEPTH<br />DRM_MODE_FLAG_3D_L_DEPTH_GFX_GFX_DEPTH<br />DRM_MODE_FLAG_3D_TOP_AND_BOTTOM<br />DRM_MODE_FLAG_3D_SIDE_BY_SIDE_HALF</pre>User space is then responsible for choosing which stereo mode to use and to prepare a buffer that matches the size and left/right placement requirements of that layout. For instance, when choosing<em> Side by Side (half)</em>, the frame buffer is the same size as its 2D equivalent (that is <code>hdisplay</code> x <code>vdisplay</code>) with the left and right images sub-sampled by 2 horizontally:<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-Neo5kpMxAvk/VrY4aNWx-gI/AAAAAAAAAZ0/OWoJ3WdFppI/s1600/sbsh.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://1.bp.blogspot.com/-Neo5kpMxAvk/VrY4aNWx-gI/AAAAAAAAAZ0/OWoJ3WdFppI/s1600/sbsh.jpg" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;"><span style="font-size: small; text-align: left;">Side by Side (half)</span></td></tr></tbody></table><br />Other modes need a bigger buffer than <code>hdisplay</code> x <code>vdisplay</code>. This is the case with <em>frame packing</em>, where each eye has the the full 2D resolution, separated by the number of vblank lines:<br /><br /><div class="separator" style="clear: both; text-align: center;"></div><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://3.bp.blogspot.com/-GPJPDMeYTcc/VrY6bGACavI/AAAAAAAAAaE/iZHl1dH9eLE/s1600/fp.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" src="https://3.bp.blogspot.com/-GPJPDMeYTcc/VrY6bGACavI/AAAAAAAAAaE/iZHl1dH9eLE/s1600/fp.jpg" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Fame Packing</td></tr></tbody></table><br />Of course, anything can be used to draw into the stereo frame buffer, including OpenGL. Further work should enable Mesa to directly render into such buffers, say with the EGL/gbm winsys for a wayland compositor to use.<br /><br /><table align="center" cellpadding="0" cellspacing="0" class="tr-caption-container" style="margin-left: auto; margin-right: auto; text-align: center;"><tbody><tr><td style="text-align: center;"><a href="https://1.bp.blogspot.com/-ARZ7hQsd5uo/VrY63aGegQI/AAAAAAAAAaI/UIqA8bq9u4M/s1600/PS3_3D2-891x1024.jpg" imageanchor="1" style="margin-left: auto; margin-right: auto;"><img border="0" height="400" src="https://1.bp.blogspot.com/-ARZ7hQsd5uo/VrY63aGegQI/AAAAAAAAAaI/UIqA8bq9u4M/s400/PS3_3D2-891x1024.jpg" width="347" /></a></td></tr><tr><td class="tr-caption" style="text-align: center;">Wipe Out using Frame Packing on the PS3</td></tr></tbody></table><br />Behind the scene, the kernel's job is to parse the EDID to discover which stereo modes the HDMI sink supports and, once user-space instructs to use a stereo mode, to send infoframes (metadata sent during the vblank interval) with the information about which 3D mode is being sent.<br /><br />A good place to start for anyone wanting to use this API is <code><a href="http://cgit.freedesktop.org/xorg/app/intel-gpu-tools/tree/tests/testdisplay.c" target="_blank">testdisplay</a></code>, part of the <a href="http://cgit.freedesktop.org/xorg/app/intel-gpu-tools/" target="_blank">Intel GPU tools</a> test suite. <code>testdisplay</code> can list the available modes with:<br /><pre class="brush: text; gutter: true">$ sudo ./tests/testdisplay -3 -i<br />[...]<br />name refresh (Hz) hdisp hss hse htot vdisp vss vse vtot flags type clock<br />[0]  1920x1080 60 1920 2008 2052 2200 1080 1084 1089 1125 0x5 0x48 148500<br />[1]  1920x1080 60 1920 2008 2052 2200 1080 1084 1089 1125 0x5 0x40 148352<br />[2]  1920x1080i 60 1920 2008 2052 2200 1080 1084 1094 1125 0x15 0x40 74250<br />[3]  1920x1080i 60 1920 2008 2052 2200 1080 1084 1094 1125 0x20015 0x40 74250 (3D:SBSH)<br />[4]  1920x1080i 60 1920 2008 2052 2200 1080 1084 1094 1125 0x15 0x40 74176<br />[5]  1920x1080i 60 1920 2008 2052 2200 1080 1084 1094 1125 0x20015 0x40 74176 (3D:SBSH)<br />[6]  1920x1080 50 1920 2448 2492 2640 1080 1084 1089 1125 0x5 0x40 148500<br />[7]  1920x1080i 50 1920 2448 2492 2640 1080 1084 1094 1125 0x15 0x40 74250<br />[8]  1920x1080i 50 1920 2448 2492 2640 1080 1084 1094 1125 0x20015 0x40 74250 (3D:SBSH)<br />[9]  1920x1080 24 1920 2558 2602 2750 1080 1084 1089 1125 0x5 0x40 74250<br />[10]  1920x1080 24 1920 2558 2602 2750 1080 1084 1089 1125 0x1c005 0x40 74250 (3D:TB)<br />[11]  1920x1080 24 1920 2558 2602 2750 1080 1084 1089 1125 0x4005 0x40 74250 (3D:FP)<br />[...]</pre>To test a specific mode:<br /><pre class="brush: text; gutter: true">$ sudo ./tests/testdisplay -3 -o 17,10<br />1920x1080 24 1920 2558 2602 2750 1080 1084 1089 1125 0x1c005 0x40 74250 (3D:TB)</pre>To cycle through all the supported stereo modes:<br /><pre class="brush: text; gutter: true">$ sudo ./tests/testdisplay -3</pre><code>testdisplay</code> uses cairo to compose the final frame buffer from two separate left and right test images.</div>
